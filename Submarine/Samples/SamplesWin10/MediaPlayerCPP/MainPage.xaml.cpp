// Ryan Baszkowski, Brennan Lambert, Nathan Loughner
// ECE 486, ECE 487, MAE 487, w/ Dr. Jenkins, Dr. Shultz, Dr. Shaw, and Dr. Wright
// Submarine Remote Operated Vehicle Project
// For client Dr. Anthony Choi
// With Dr. Choi, Dr. Fu, and Dr. Sumner as advisiors
// And with Dr. Wright as project manager
//// Submarine ROV Network Remote Controller
//// Implementation file
// First build on 23 January 2019

// Ryan is the primary author of the code, comments are from him unless otherwise noted.
// More so than the submarine groups before us, we want to take into account that the project
// will be continued by future senior design groups and provide adequate documentation.

// You might question the decision to go with a Universal Windows Program application.
// I knew I definately wanted to write for Windows because I wanted access to Xinput/Windows.Gaming.Input
// due to the simplicity of interfacing with game controllers they provide.
// There are two alternatives to writing an application for Windows in Visual Studio, 
// Windows Forms and WPF. WPF is the newer standard, I think introduced in
// Vista - 7 timeframe, but I had heard  from peers in the engineering school about how unpleasant
// developing in it is. Windows Forms is rather antiquated, so I decided to give the UWP a try.
// If the entire Universal Windows Platform has died out by the time my successor is given this - Sorry!

// The language you see here is C++/CX, which is the newest language that can be referred to as Visual C++.
// While it is still C++ at its core, there are a lot of things which do not necessarily follow
// ISO C++, and a few more that do not follow C++/CLI, used in WPF and Windows Forms.
// I will attempt to point these things out and explain them in comments here.
// In general, just because something works in regular C++, you can't assume it will work here.

// Modified from Microsoft's default implementation of the MainPage in C++/CX,
// available from them at https://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409

#include "pch.h"
#include "MainPage.xaml.h"
#include <ppltasks.h>
#include <sstream>
#include <ppl.h>

using namespace Submarine;

// This is all stuff for the UI, generated by default upon project creation
using namespace Platform;
using namespace Windows::Foundation;
using namespace Windows::Foundation::Collections;
using namespace Windows::UI::Xaml;
using namespace Windows::UI::Xaml::Controls;
using namespace Windows::UI::Xaml::Controls::Primitives;
using namespace Windows::UI::Xaml::Data;
using namespace Windows::UI::Xaml::Input;
using namespace Windows::UI::Xaml::Media;
using namespace Windows::UI::Xaml::Navigation;

// These are namespaces are my own inclusions
using namespace Windows::Web::Http; // For network communication
using namespace Windows::Gaming::Input; // For gamepads
using namespace concurrency; // For running tasks in the background, like network communication
using namespace Platform::Collections; // For vectors
using namespace FFmpegInterop;
using namespace Windows::Media::Core;
using namespace Windows::UI::Popups;

// Global Variables and Objects
auto client = ref new HttpClient(); // Object which handles network communication
String^ camAddr = "192.168.1.189"; // Camera URL, this is the manufacturer's default
String^ contAddr = "192.168.1.182"; // Arduino URL, this is the static IP assigned
String^ rawRec = "null";
bool showtime = false;

// Sensor Data
String^ internalTemp;
String^ externalTemp;
String^ pressure;
String^ depth;
String^ alt;
String^ x_o;
String^ y_o;
String^ z_o;

// Servo Microsecond Values
int left = 1500, top = 1500, front = 1500, back = 1500, bottom = 1500, right = 1500, light = 1100;

//// These hold the user's requested controls. Each of the three input devices modifies these.
//// They are named for the key configuration
bool c_w = false, c_a = false, c_s = false, c_d = false, c_i = false, c_j = false, c_k = false,
c_l = false, c_q = false, c_e = false, c_sh = false, c_sp = false;

// Gamepad Stuff
Gamepad^ gamepad = nullptr; // Instantiate the gamepad class to get the list of connected gamepads
Vector<Gamepad^>^ padList = ref new Vector<Gamepad^>(); // Store our own list of gamepads, recommended by Microsoft
double deadzone = 0.35; // Deadzone for the analog sticks to activate

MainPage::MainPage()
{
	InitializeComponent(); // Given automatically by VS

	sensToScreen(); // Apply the proper formatting to the TextBlocks in the GUI at launch
	servToScreen();
	contip->Text = contAddr;
	camip->Text = camAddr;
}

//////////////////////////////////////////////GUI EVENT HANDLERS/////////////////////////////////////////////

// Show and hide the sensor data upon clicking the appropriate button
// I make these early on while I was still unfamiliar with all of this.
// With what I've learned now, you could definately consolodate these functions into one by casting the "sender" as a Button^
// and checking which button was pressed. I do this with buttons handling pilot control inputs because having a function for each
// would have been frankly absurd, so figuring the right way out was necessary. I don't really have the time to go back and fix these, however.
void Submarine::MainPage::sensorData_click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e)
{
	if (sensors->Visibility == Windows::UI::Xaml::Visibility::Visible) { //
		sensors->Visibility = Windows::UI::Xaml::Visibility::Collapsed;
		sensorData->Content = "Show Sensor and ESC Data";
	}
	else {
		sensors->Visibility = Windows::UI::Xaml::Visibility::Visible;
		sensorData->Content = "Hide Sensor and ESC Data";
	}
	if (servos->Visibility == Windows::UI::Xaml::Visibility::Visible) {
		servos->Visibility = Windows::UI::Xaml::Visibility::Collapsed;
	}
	else {
		servos->Visibility = Windows::UI::Xaml::Visibility::Visible;
	}
}

// Show and hide the on screen controls upon clicking the appropriate button
void Submarine::MainPage::controls_click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e)
{
	if (OSControls->Visibility == Windows::UI::Xaml::Visibility::Visible) {
		OSControls->Visibility = Windows::UI::Xaml::Visibility::Collapsed;
		controls->Content = "Show On-Screen Controls";
	}
	else {
		OSControls->Visibility = Windows::UI::Xaml::Visibility::Visible;
		controls->Content = "Hide On-Screen Controls";
	}
	ESCOverrides->Visibility = Windows::UI::Xaml::Visibility::Collapsed;
	manualcont->Content = "Show ESC Overrides";
}

// Take in the user's input in the GUI as the value of the global variables for the IP addresses
void Submarine::MainPage::connect_click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e)
{
	camAddr = camip->Text;
	contAddr = contip->Text;

	auto timer = ref new DispatcherTimer(); // Create a timer on which to talk to the Arduino. This is the easiest way to loop code in GUI
	TimeSpan ts; // For some reason this needs it's own datatype, the span of time between timer ticks
	ts.Duration = 100000; // Set the time between timer ticks here. For some reason this is in 0.0000001 seconds, so this is 10 ms
	timer->Interval = ts; // Set the interval
	auto doit = timer->Tick += ref new EventHandler<Object^>(this, &MainPage::sendRequest); // Attach network communication to the timer
	timer->Start(); // Start the timer

	// Make a string for the full address for the RTSP stream.
	// Annoyingly, this URL format is different for just about every model of IPCam, so this only applies to the ESCAM QH002 that we used
	// We intend for everything in this project to be upgradeable, so this is a problem if students/Dr. Choi down the line want to upgrade the camera
	// Luckily, I found some software called ONVIF that you can use to give you the stream to any IP Camera. Give it a Google.
	String^ camStream = "rtsp://" + camAddr + "/ch01.264?dev=1";
	//String^ camStream = "rtsp://192.168.1.189/ch01.264?dev=1";
	PropertySet^ options = ref new PropertySet();
	// Below are some sample options that you can set to configure RTSP streaming
	options->Insert("rtsp_flags", "prefer_tcp");
	// options->Insert("stimeout", 100000);
	// Instantiate FFmpegInteropMSS using the URI
	camfeed->Stop();
	FFmpegMSS = FFmpegInteropMSS::CreateFFmpegInteropMSSFromUri(camStream, true, true, options);
	if (FFmpegMSS != nullptr) {
		MediaStreamSource^ mss = FFmpegMSS->GetMediaStreamSource();
		if (mss) {
			// Pass MediaStreamSource to Media Element
			camfeed->SetMediaStreamSource(mss);
		}
		else {
			auto errorDialog = ref new MessageDialog("Camera Error 1"); errorDialog->ShowAsync();
		}
	}
	else {
		auto errorDialog = ref new MessageDialog("Camera Error 2"); errorDialog->ShowAsync();
	}
}

void Submarine::MainPage::Manualcont_Click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e)
{
	if (ESCOverrides->Visibility == Windows::UI::Xaml::Visibility::Visible) {
		ESCOverrides->Visibility = Windows::UI::Xaml::Visibility::Collapsed;
		manualcont->Content = "Show ESC Overrides";
	}
	else {
		ESCOverrides->Visibility = Windows::UI::Xaml::Visibility::Visible;
		manualcont->Content = "Hide ESC Overrides";
	}
	OSControls->Visibility = Windows::UI::Xaml::Visibility::Collapsed;
	controls->Content = "Show On-Screen Controls";
}

void Submarine::MainPage::brightness(Platform::Object^ sender, Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs^ e)
{
	light = ((((Slider^)sender)->Value * 8) + 1100);
	servToScreen();
}

//Handle clicking of the servo override buttons
void Submarine::MainPage::override_click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e)
{
	if (((Button^)sender)->Name == "leftplus")
		left = 1575;
	if (((Button^)sender)->Name == "topplus")
		top = 1650;
	if (((Button^)sender)->Name == "frontplus")
		front = 1650;
	if (((Button^)sender)->Name == "backplus")
		back = 1650;
	if (((Button^)sender)->Name == "bottomplus")
		bottom = 1650;
	if (((Button^)sender)->Name == "rightplus")
		right = 1575;
	if (((Button^)sender)->Name == "leftminus")
		left = 1425;
	if (((Button^)sender)->Name == "topminus")
		top = 1350;
	if (((Button^)sender)->Name == "frontminus")
		front = 1350;
	if (((Button^)sender)->Name == "backminus")
		back = 1350;
	if (((Button^)sender)->Name == "bottomminus")
		bottom = 1350;
	if (((Button^)sender)->Name == "rightminus")
		right = 1425;
	if (((Button^)sender)->Name == "kill" || ((Button^)sender)->Name == "killov") {
		left = 1500;
		top = 1500;
		front = 1500;
		back = 1500;
		bottom = 1500;
		right = 1500;
	}
	servToScreen();
}

// Handling control inputs given through the keyboard
void Submarine::MainPage::kbdInput(Platform::Object^ sender, Windows::UI::Xaml::Input::KeyRoutedEventArgs^ e)
{
	if (e->Key == Windows::System::VirtualKey::W)
		c_w = true;
	if (e->Key == Windows::System::VirtualKey::A)
		c_a = true;
	if (e->Key == Windows::System::VirtualKey::S)
		c_s = true;
	if (e->Key == Windows::System::VirtualKey::D)
		c_d = true;
	if (e->Key == Windows::System::VirtualKey::I)
		c_i = true;
	if (e->Key == Windows::System::VirtualKey::J)
		c_j = true;
	if (e->Key == Windows::System::VirtualKey::K)
		c_k = true;
	if (e->Key == Windows::System::VirtualKey::L)
		c_l = true;
	if (e->Key == Windows::System::VirtualKey::Q)
		c_q = true;
	if (e->Key == Windows::System::VirtualKey::E)
		c_e = true;
	if (e->Key == Windows::System::VirtualKey::LeftShift)
		c_sh = true;
	if (e->Key == Windows::System::VirtualKey::Space)
		c_sp = true;

}

void Submarine::MainPage::kbdRelease(Platform::Object^ sender, Windows::UI::Xaml::Input::KeyRoutedEventArgs^ e)
{
	if (e->Key == Windows::System::VirtualKey::W)
		c_w = false;
	if (e->Key == Windows::System::VirtualKey::A)
		c_a = false;
	if (e->Key == Windows::System::VirtualKey::S)
		c_s = false;
	if (e->Key == Windows::System::VirtualKey::D)
		c_d = false;
	if (e->Key == Windows::System::VirtualKey::I)
		c_i = false;
	if (e->Key == Windows::System::VirtualKey::J)
		c_j = false;
	if (e->Key == Windows::System::VirtualKey::K)
		c_k = false;
	if (e->Key == Windows::System::VirtualKey::L)
		c_l = false;
	if (e->Key == Windows::System::VirtualKey::Q)
		c_q = false;
	if (e->Key == Windows::System::VirtualKey::E)
		c_e = false;
	if (e->Key == Windows::System::VirtualKey::LeftShift)
		c_sh = false;
	if (e->Key == Windows::System::VirtualKey::Space)
		c_sp = false;
}

void Submarine::MainPage::Xboxc_Click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e)
{
	if (padList->Size > 0) {
		auto timer = ref new DispatcherTimer(); // Create a timer on which to poll the gamepad, just like we did with the network communication
		TimeSpan ts; // For some reason this needs it's own datatype, the span of time between timer ticks
		ts.Duration = 100000; // Set the time between timer ticks here. For some reason this is in 0.0000001 seconds, so this is 10 ms
		timer->Interval = ts; // Set the interval
		auto doit = timer->Tick += ref new EventHandler<Object^>(this, &MainPage::pollPad); // Attach network communication to the timer
		timer->Start(); // Start the timer
	}
}

void Submarine::MainPage::camfail(Platform::Object^ sender, Windows::UI::Xaml::ExceptionRoutedEventArgs^ e)
{
	auto errorDialog = ref new MessageDialog("Media Failed"); errorDialog->ShowAsync();
}

////////////////////////////////////////////////////////////////OTHER FUNCTIONS////////////////////////////////////////////////////////////////

// Perform a HTML GET request.
// This implementation of submarine drone and controller does control communication with GET requests.
// Control inputs will be encoded into strings sent to the submarine microcontroller to decode and perform
// There absolutely must be a better way to do this, but I lack either the intelligence or initiative to find it
// Hopefully, the people who inherit this from me later will be smart enough do better.
// For what it's worth, I do believe I can pull this off in a way that's not too bad.
void Submarine::MainPage::sendRequest(Object^ sender, Object^ e) {
	// This is the formatted control code which is sent as a GET request and parsed by the Arduino
	String^ encodedReq = "http://" + contAddr + "/$" + left + "-" + top + "-" + front + "-" + back + "-" + bottom + "-" + right + "-" + light + "__opcode";
	auto uri = ref new Uri(encodedReq); // Go from string to Uri for the address of the Arduino and the command to be sent
	try { // Exception handling is absolutely necessary for network stuff
		// Sending the GET request and saving the reponse (the sensor data code)
		// Network communication is an Asynchronous operation, and figuring this out was a nightmare
		// There are a couple of ways it can store the response for you, "GetStringAsync" is what I picked and what is important in this line 
		auto talk = create_task(client->GetStringAsync(uri)); // Create the task and execute it Asynchronously
		talk.then([this](String^ sens) { // Provide the lambda of what to do, the "codeParse" function in our case
			rawRec = sens;
			codeParse(sens->Data()); // Parse the sensor code "->Data()" gives a std::wstring; this is necessary for parsing
		});
	}
	catch (COMException^ ex) {
		servos->Text += ("\n" + ex->Message);
	}
}

void Submarine::MainPage::codeParse(std::wstring item) {
	std::wstringstream stream(item); // On the Arduino, we did C-type parsing
	std::wstring token; // 
	std::wstring data[8];
	int c = 0;
	while (std::getline(stream, token, (wchar_t)'#')) {
		data[c] = token;
		c++;
	}
	internalTemp = ref new String(data[0].c_str());
	externalTemp = ref new String(data[1].c_str());
	pressure = ref new String(data[2].c_str());
	depth = ref new String(data[3].c_str());
	alt = ref new String(data[4].c_str());
	x_o = ref new String(data[5].c_str());
	y_o = ref new String(data[6].c_str());
	z_o = ref new String(data[7].c_str());
	sensToScreen(); // Update
	servToScreen();
}

void Submarine::MainPage::sensToScreen() { // Getting the sensor data into the TextBlock and formatting it nicely
	sensors->Text = "Sensor Readings\n" +
		"Internal Temperature\t" + internalTemp + " °C\n" +
		"External Temperature\t" + externalTemp + " °C\n" +
		"Pressure\t\t\t" + pressure + " mbar\n" +
		"Depth\t\t\t" + depth + " m\n" +
		"Altitude\t\t\t" + alt + " m above mean sea level\n" +
		"\nOrientation Data\n"
		"X Orientation\t\t" + x_o + "\n" +
		"Y Orientation\t\t" + y_o + "\n" +
		"Z Orientation\t\t" + z_o + "\n"; // + 
		//"\nRaw\n" + rawRec;
}

void Submarine::MainPage::servToScreen() { // Getting the ESC and headlight data into the TextBlock and formatting it nicely
	servos->Text = "ESC Data\n" +
		"Left\t" + ((left - 1500) / 4) + " %\t" + left + " microseconds\n" +
		"Top\t" + ((top - 1500) / 4) + " %\t" + top + " microseconds\n" +
		"Front\t" + ((front - 1500) / 4) + " %\t" + front + " microseconds\n" +
		"Back\t" + ((back - 1500) / 4) + " %\t" + back + " microseconds\n" +
		"Bottom\t" + ((bottom - 1500) / 4) + " %\t" + bottom + " microseconds\n" +
		"Right\t" + ((right - 1500) / 4) + " %\t" + right + " microseconds\n" +
		"\nHeadlight Brightness\n" + ((light - 1100) / 8) + " %\t" + light + " microseconds\n";
}

void Submarine::MainPage::pollPad(Object^ sender, Object^ e) {
	auto userpad = padList->GetAt(0); // Get the first of the list of gamepads
	auto state = userpad->GetCurrentReading();

}

// A note on maximum thruster speeds in the early versions of the code:
// Each thruster has a hard cap on its speed so as to not trip the 30 A breaker or overheat the power wire
// A maximum of 30 A and 6 thrusters means a safe max of 5 A. Each ESC can pull up to 12.5 A.
// 5 A / 12.5 A means the maximum percentage that each thruster can be activated is 40%
// 1500 microseconds is the stop command for the ESCs, and 1900 is max forward and 1100 is max backward,
// so the difference between max and off is 400 microseconds. 400 times 40% is 160, so 1500 +- 160 is the maximum speed microseconds value


